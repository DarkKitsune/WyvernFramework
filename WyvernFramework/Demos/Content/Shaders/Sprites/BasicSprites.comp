#version 450

const int MAX_LISTS = 32;
const int MAX_ANIMATION_INSTRUCTIONS = 64;

const int INST_SETTIME = 1;
const int INST_SETSCALE = 2;
const int INST_LERPSCALE = 3;

layout (local_size_x = 1024) in;

struct Instruction
{
    vec4 Argument;
    int Type;
    float Time;
};

struct Animation
{
    int Length;
    Instruction Instruction[MAX_ANIMATION_INSTRUCTIONS];
};

struct Instance
{
    vec3 Position;
    vec3 Velocity;
    vec4 Rectangle;
    vec2 Scale;
    int ListIndex;
    float Time;
    float AnimationTime;
};

layout (std140, binding = 0) buffer buffer_Instances
{
    Instance instances[];
};

layout (std140, binding = 1) uniform struct_Time
{
    float listTime[MAX_LISTS];
} time;

layout (std140, binding = 2) uniform struct_Animation
{
    Animation animation[MAX_LISTS];
} animation;

Instance doMovement(Instance instance, float deltaTime)
{
    instance.Position += instance.Velocity * deltaTime;
    return instance;
}

Instance doAnimation(Instance instance)
{
    Animation anim = animation.animation[instance.ListIndex];
    for (int i = 0; i < anim.Length; i++)
    {
        Instruction instruction = anim.Instruction[i];
        float applies = float(instruction.Time <= instance.AnimationTime);
        vec4 arg = instruction.Argument;
        float interpLength = instruction.Argument.x;
        vec3 interpArg = instruction.Argument.yzw;
        float interpRatio = clamp((instance.AnimationTime - instruction.Time) / interpLength, 0.0, 1.0);

        instance.Scale = mix(instance.Scale, arg.xy, applies * float(instruction.Type == INST_SETSCALE));
        instance.Scale = mix(instance.Scale, interpArg.xy, applies * float(instruction.Type == INST_LERPSCALE) * interpRatio);
        instance.AnimationTime = mix(instance.AnimationTime, arg.x, applies * float(instruction.Type == INST_SETTIME));
    }
    return instance;
}

void main() 
{
    // Acquire instance and info
    uint index = gl_GlobalInvocationID.x;
    Instance instance = instances[index];
    float currentTime = time.listTime[instance.ListIndex];
    float previousTime = instance.Time;
    float deltaTime = currentTime - previousTime;

    // Do logic
    instance = doMovement(instance, deltaTime);
    instance = doAnimation(instance);

    // Update instance time and store it back in the buffer
    instance.Time = currentTime;
    instance.AnimationTime += deltaTime;
    instances[index] = instance;
}
